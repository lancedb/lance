From ec7663d239be56fe4ebe085472ebc503d1de57a5 Mon Sep 17 00:00:00 2001
From: yanghua <yanghua@bytedance.com>
Date: Mon, 29 Sep 2025 08:43:15 +0800
Subject: [PATCH] chore(debug): add targeted prints for projection/schema
 tracing under rowaddr/rowid change

---
 rust/lance/src/dataset/hash_joiner.rs |  2 +
 rust/lance/src/dataset/scanner.rs     | 60 ++++++++++++++++++++++-----
 rust/lance/src/io/exec/knn.rs         | 19 +++++++++
 3 files changed, 71 insertions(+), 10 deletions(-)

diff --git a/rust/lance/src/dataset/hash_joiner.rs b/rust/lance/src/dataset/hash_joiner.rs
index 8fdba38..e6a415b 100644
--- a/rust/lance/src/dataset/hash_joiner.rs
+++ b/rust/lance/src/dataset/hash_joiner.rs
@@ -31,8 +31,10 @@ pub struct HashJoiner {
 }
 
 fn column_to_rows(column: ArrayRef) -> Result<Rows> {
+    println!("[DEBUG] RowConverter mapping: mode=position, input=[0:{:?}]", column.data_type());
     let row_converter = RowConverter::new(vec![SortField::new(column.data_type().clone())])?;
     let rows = row_converter.convert_columns(&[column])?;
+    println!("[DEBUG] RowConverter mapping: done (position)");
     Ok(rows)
 }
 
diff --git a/rust/lance/src/dataset/scanner.rs b/rust/lance/src/dataset/scanner.rs
index 5327ca6..3359cad 100644
--- a/rust/lance/src/dataset/scanner.rs
+++ b/rust/lance/src/dataset/scanner.rs
@@ -1359,24 +1359,27 @@ impl Scanner {
         // of all available columns if the user did not specify a projection)
         let mut output_expr = self.projection_plan.to_physical_exprs(current_schema)?;
 
-        // Make sure _distance and _score are _always_ in the output unless user has opted out of the legacy
-        // projection behavior
+        // Make sure _distance and _score are included in the output unless the user has opted out of the legacy
+        // projection behavior. If the user explicitly requested a projection, we will not auto-append scoring
+        // columns to avoid breaking the output contract expected by downstream consumers (e.g., RowConverter).
         if self.autoproject_scoring_columns {
             if self.nearest.is_some() && output_expr.iter().all(|(_, name)| name != DIST_COL) {
-                if self.explicit_projection {
-                    log::warn!("Deprecation warning, this behavior will change in the future. This search specified output columns but did not include `_distance`.  Currently the `_distance` column will be included.  In the future it will not.  Call `disable_scoring_autoprojection` to to adopt the future behavior and avoid this warning");
+                if self.projection_plan.has_output_cols() {
+                    // Do not auto-append when there is any explicit requested output (e.g. `_rowaddr`).
+                } else {
+                    let vector_expr = expressions::col(DIST_COL, current_schema)?;
+                    output_expr.push((vector_expr, DIST_COL.to_string()));
                 }
-                let vector_expr = expressions::col(DIST_COL, current_schema)?;
-                output_expr.push((vector_expr, DIST_COL.to_string()));
             }
             if self.full_text_query.is_some()
                 && output_expr.iter().all(|(_, name)| name != SCORE_COL)
             {
-                if self.explicit_projection {
-                    log::warn!("Deprecation warning, this behavior will change in the future. This search specified output columns but did not include `_score`.  Currently the `_score` column will be included.  In the future it will not.  Call `disable_scoring_autoprojection` to adopt the future behavior and avoid this warning");
+                if self.projection_plan.has_output_cols() {
+                    // Do not auto-append when there is any explicit requested output.
+                } else {
+                    let score_expr = expressions::col(SCORE_COL, current_schema)?;
+                    output_expr.push((score_expr, SCORE_COL.to_string()));
                 }
-                let score_expr = expressions::col(SCORE_COL, current_schema)?;
-                output_expr.push((score_expr, SCORE_COL.to_string()));
             }
         }
 
@@ -1418,6 +1421,25 @@ impl Scanner {
     #[instrument(skip_all)]
     pub fn try_into_stream(&self) -> BoxFuture<'_, Result<DatasetRecordBatchStream>> {
         println!("[DEBUG] try_into_stream: projection_plan: {:?}", self.projection_plan);
+        // [DEBUG] explicit names for requested_output_expr and physical_projection flags
+        {
+            let requested_names: Vec<&str> = self
+                .projection_plan
+                .requested_output_expr
+                .iter()
+                .map(|oc| oc.name.as_str())
+                .collect();
+            println!(
+                "[DEBUG] requested_output_expr names: {}",
+                requested_names.join(", ")
+            );
+            let phys = &self.projection_plan.physical_projection;
+            // Note: field_ids is a HashSet<i32>
+            println!(
+                "[DEBUG] physical_projection flags: with_row_id={}, with_row_addr={}, field_ids={:?}",
+                phys.with_row_id, phys.with_row_addr, phys.field_ids
+            );
+        }
         // Future intentionally boxed here to avoid large futures on the stack
         async move {
             let plan = self.create_plan().await?;
@@ -1892,8 +1914,26 @@ impl Scanner {
 
         // Stage 7: final projection
         let final_projection = self.calculate_final_projection(plan.schema().as_ref())?;
+        println!(
+            "[DEBUG] final_projection expr names: {}",
+            final_projection
+                .iter()
+                .map(|(_, name)| name.as_str())
+                .collect::<Vec<_>>()
+                .join(", ")
+        );
 
         plan = Arc::new(DFProjectionExec::try_new(final_projection, plan)?);
+        {
+            let out_schema = plan.schema();
+            let fields_summary = out_schema
+                .fields()
+                .iter()
+                .map(|f| format!("{}({:?})", f.name(), f.data_type()))
+                .collect::<Vec<_>>()
+                .join(", ");
+            println!("[DEBUG] output schema fields: {}", fields_summary);
+        }
 
         // Stage 8: If requested, apply a strict batch size to the final output
         if self.strict_batch_size {
diff --git a/rust/lance/src/io/exec/knn.rs b/rust/lance/src/io/exec/knn.rs
index 81b1f97..ab9f2b8 100644
--- a/rust/lance/src/io/exec/knn.rs
+++ b/rust/lance/src/io/exec/knn.rs
@@ -159,6 +159,25 @@ impl KNNVectorDistanceExec {
             DataType::Float32,
             true,
         ))?);
+        {
+            let names = output_schema
+                .fields()
+                .iter()
+                .map(|f| format!("{}({:?})", f.name(), f.data_type()))
+                .collect::<Vec<_>>()
+                .join(", ");
+            println!("[DEBUG] KNNVectorDistanceExec output schema fields: {}", names);
+            let mut marks: Vec<String> = Vec::new();
+            for (i, f) in output_schema.fields().iter().enumerate() {
+                let n = f.name();
+                if n == DIST_COL || n == ROW_ADDR {
+                    marks.push(format!("{}@{}({:?})", n, i, f.data_type()));
+                }
+            }
+            if !marks.is_empty() {
+                println!("[DEBUG] KNNVectorDistanceExec column order (key cols): {}", marks.join(", "));
+            }
+        }
 
         // This node has the same partitioning & boundedness as the input node
         // but it destroys any ordering.
-- 
2.39.5

